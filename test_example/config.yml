# === Analysis configuration file ======================================================


# --- Configuration for `seqneut-pipeline` ---------------------------------------------

# Location of `seqneut-pipeline` submodule, typically "seqneut-pipeline"
# **FOR THIS TEST EXAMPLE ONLY, THIS LOCATION IS "../" BUT IT SHOULD
# ALMOST CERTAINLY BE "seqneut-pipeline" FOR REAL ANALYSES**
seqneut-pipeline: ../

# Location where we place the docs for rendering on GitHub Pages, typically "docs"
# **FOR THIS TEST EXAMPLE ONLY, THIS LOCATION IS "../docs" BUT IT SHOULD
# ALMOST CERTAINLY BE "docs" FOR REAL ANALYSES**
docs: ../docs

# Description of the project in markdown, should have title, authors and/or citation,
# and link to the GitHub repo.
# **CHANGE THIS TO A GOOD DESCRIPTION OF YOUR PROJECT**
description: |
  # Test example for [seqneut-pipeline](https://github.com/jbloomlab/seqneut-pipeline)
  This is a small toy-example created by subsetting a real experiment dataset.

  See [https://github.com/jbloomlab/seqneut-pipeline](https://github.com/jbloomlab/seqneut-pipeline)
  for the computer code and underlying numerical data.

  See [here](https://github.com/jbloomlab/seqneut-pipeline/graphs/contributors) for a
  list of all contributors to the pipeline.

# Specify each viral library and corresponding CSV matching barcode to strain name
# CSV must have columns "barcode" and "strain"
viral_libraries:
  pdmH1N1_lib2023_loes: data/viral_libraries/pdmH1N1_lib2023_loes.csv

# If you want to plot the viral strains in a specific order, provide a CSV with
# column "strain" ordered in that order. If you omit or set to "null", strains
# will be plotted alphabetically.
viral_strain_plot_order: data/viral_strain_plot_order.csv

# Specify the name of each set of neutralization standards and corresponding CSV
# with a column "barcode" listing the barcodes
neut_standard_sets:
  loes2023: data/neut_standard_sets/loes2023_neut_standards.csv

# keyword parameters for `dms_variants.illuminabarcodeparser.IlluminaBarcodeParser`
# https://jbloomlab.github.io/dms_variants/dms_variants.illuminabarcodeparser.html#dms_variants.illuminabarcodeparser.IlluminaBarcodeParser
illumina_barcode_parser_params:
  upstream: CTCCCTACAATGTCGGATTTGTATTTAATAG
  downstream: ''
  minq: 20
  upstream_mismatch: 4
  bc_orientation: R2

# Specify the data for each neutralization plate in `plates`. Specify each plate as
#
#  plate_name:
#    date: <sequencing date in YYYY-MM-DD format>
#    viral_library: <name of a viral library>
#    neut_standard_set: <name of a neut standard set>
#    samples_csv: <samples in plate as CSV> 
#    qc_thresholds:
#      avg_barcode_counts_per_well: <drop well if < this many avg counts per barcode>
#      min_neut_standard_frac_per_well: <drop well if < this frac counts from neut standard>
#      no_serum_barcode_consistency: <drop viral barcode if not consistent in frac in no-serum wells>
#        max_fold_change: 3
#        max_wells: 2
#      neut_standard_barcode_consistency: <drop neut standard barcodes not consistent in frac in all wells>
#        max_fold_change: 3
#        max_wells: 2
#
#      min_neut_standard_counts: <require this many counts from neut standard per well>
#      min_viral_barcode_frac: <require this frac viral barcode counts for each barcode in no-serum sample>
#      min_neut_standard_counts: <require this many total neut-standard counts per sample>
#      min_viral_barcode_counts: <require this many counts for each viral barcode in each no-serum sample>

#      max_barcode_frac_infectivity: 
#
#      min_no_serum_viral_barcode_count: <require this many counts for each viral barcode in each no-serum sample>
#      min_dilutions_per_serum_replicate: <require this many different dilutions per serum replicate>
#      max_frac_infectivity: <require frac infectivity estimates to be no greater than this>
#    barcodes_to_drop: <list of barcodes to drop for this plate>
#    wells_to_drop: <list of wells to drop for this plate>
#    curvefit_params:
#      frac_infectivity_ceiling: <ceiling to apply to frac infectivity before curve fitting, typically 1 if used>
#      fixtop: <do we fix top of neutralization curves in fitting, typically either 1 or false>
#      fixbottom: <do we fix bottom of neutralization curves in fitting, typically either 0 or false>
#
# The samples_csv must have columns "well", "serum", "dilution_factor", "replicate", and "fastq".
# Other columns (eg,  "notes") are allowed but are not used by the pipeline.
#
# The "replicate" column indicates readings that go together as a replicate for that
# serum, and only has to be unique for that serum within that plate (so you can put any
# any value if the serum is only run once on that plate).
#
# Each plate must have at least one no-serum column that should have a serum entry of
# "none" and no concentration specified (nan). Note that each "none" entry in a plate
# must have a different "replicate" specified.

# default `process_counts_qc_thresholds` that can be used with merge key
# (https://ktomk.github.io/writing/yaml-anchor-alias-and-merge-key.html)
default_process_plate_qc_thresholds: &default_process_plate_qc_thresholds
  avg_barcode_counts_per_well: 250  # 250 for this test, typically >= 500 for real experiments
  min_neut_standard_frac_per_well: 0.005
  no_serum_per_viral_barcode_filters:
    min_frac: 0.0005
    max_fold_change: 3
    max_wells: 2
  per_neut_standard_barcode_filters:
    min_frac: 0.005
    max_fold_change: 3
    max_wells: 2
  min_neut_standard_count_per_well: 1000
  min_no_serum_count_per_viral_barcode_well: 30
  max_frac_infectivity_per_viral_barcode_well: 5

  min_dilutions_per_serum_replicate: 4

# default `curvefit_params` that can be used with merge key
default_curvefit_params: &default_curvefit_params
  frac_infectivity_ceiling: 1
  fixtop: false
  fixbottom: 0

plates:

  plate2:
    date: 2023-08-01
    viral_library: pdmH1N1_lib2023_loes
    neut_standard_set: loes2023
    samples_csv: data/plates/plate2_samples.csv
    qc_thresholds:
      <<: *default_process_plate_qc_thresholds
    barcodes_to_drop:
      - GGTCCATCTCAGATCG
    wells_to_drop:
      - C1  # low neut standard frac
      - D12  # low neut standard frac
    curvefit_params:
      <<: *default_curvefit_params

  plate11:
    date: 2023-09-26
    viral_library: pdmH1N1_lib2023_loes
    neut_standard_set: loes2023
    samples_csv: data/plates/plate11_samples.csv
    qc_thresholds:
      <<: *default_process_plate_qc_thresholds
    barcodes_to_drop:
      - GGTCCATCTCAGATCG
    wells_to_drop:
      - D6  # low overall barcode counts
      - C12  # low neut standard frac
    curvefit_params:
      <<: *default_curvefit_params

# QC thresholds on per-serum virus titers. Each serum-virus titer must meet these QC
# thresholds or be specified in `serum_titers_qc_exclusions`. Otherwise titer is flagged
# as failing.
serum_titers_qc_thresholds:
  min_frac_infectivity: 0.7  # require one concentration with frac_infectivity >= this, if not >0.5 will be no IC50
  min_replicates: 2  # require at least this many replicates for a serum-virus pair
  max_fold_change_from_median: 3  # no replicate can have a titer more than this fold different from repicate median

# Specify exclusions from `serum_titers_qc_thresholds. For any serum that is failing the QC, put
# a key under `serum_titer_qc_thresholds` with the name of that serum. Under that serum, in
# turn put a key with the name of the virus strain. You then have two options. You can either
# put the subkey `ignore_qc: true` to totally ignore the `serum_tiers_qc_thresholds` for that
# serum-virus pair. Alternatively, you can put `replicates_to_drop` as key followed by a
# list of the replicate names to drop (if you put all of the replicates, that virus will be
# dropped altogether for the tiers). The replicate names here are those rendered in the plots
# by the `serum_titers` notebook, which are usually of the form "{plate}-{barcode}" possibly
# with an additional plate-replicate specifier.
serum_titers_qc_exclusions:

  M099d0:
    A/Bangladesh/8002/2021:
      ignore_qc: true  # many replicates, so ignore the extra variation around median
    A/Brisbane/02/2018:
      ignore_qc: true  # many replicates, so ignore the extra variation around median
    A/Norway/25089/2022:
      replicates_to_drop:
        - plate11-CGGATAAAAATGATAT  # NT50 is an outlier
    A/Wisconsin/588/2019:
      replicates_to_drop:
        - plate11-AGTCCTATCCTCAAAT  # NT50 is an outlier
    A/SouthAfrica/R16462/2021:
      replicates_to_drop:
        - plate2-CTAGCAGATTGTATAA  # NT50 is an outlier

  M099d30:
    A/Chester/5355/2022:
      replicates_to_drop:
        - plate11-CCTCAAAATAACAAGC  # NT50 is an outlier
    A/Michigan/45/2015:
      ignore_qc: true  # replicates are close enough to probably be OK
    A/Paris/31196/2021:
      ignore_qc: true  # replicates are close enough to probably be OK

  Y044d30:
    A/Bangladesh/8036/2021:
      ignore_qc: true  # replicates about evenly spaced so unclear if any are outliers
    A/Brisbane/48/2022:
      ignore_qc: true  # replicates about evenly spaced so unclear if any are outliers
    A/India-PUN-NIV328484/2021:
      ignore_qc: true  # replicates about evenly spaced so unclear if any are outliers
    A/Perth/1/2022:
      ignore_qc: true  # replicates about evenly spaced so unclear if any are outliers
    A/Washington/23/2020:
      ignore_qc: true  # replicates about evenly spaced so unclear if any are outliers
